// automatically generated by Xtext
grammar org.buildingsmart.mvd.tmvd.TextualMVD with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2003/XMLType" as type
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://buildingsmart-tech.org/mvdXML/mvdXML1-1"

MvdXML returns MvdXML:
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	('version' version=NORMALIZED_STRING)?
	'mvd' name=MVD_NAME 'uuid' uuid=UUID
	';'
	('templates' templates=TemplatesType)?
	('views' views=ViewsType)?;

TemplatesType returns TemplatesType:
	'[' conceptTemplate+=ConceptTemplate ("," conceptTemplate+=ConceptTemplate)* ']';

ViewsType returns ViewsType:
	'[' modelView+=ModelView ("," modelView+=ModelView)* ']';

terminal NORMALIZED_STRING returns type::NormalizedString:
	STRING;

terminal MVD_NAME returns type::NormalizedString:
	ID;

AnyURI returns type::AnyURI:
	'AnyURI' STRING /* TODO: implement this rule and an appropriate IValueConverter */;

enum StatusType returns StatusType:
	sample='sample' | proposal='proposal' | draft='draft' | candidate='candidate' | final='final' |
	deprecated='deprecated' | noStatus='noStatus';

ConceptTemplate returns ConceptTemplate:
	'ConceptTemplate' name=ID
	'{'
	('applicableEntity' applicableEntity=ApplicableEntityType)?
	'applicableSchema' applicableSchema=ApplicableSchemaType
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('isPartial' isPartial=Boolean)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	'uuid' uuid=UUID
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	('rules' rules=RulesType)?
	('subTemplates' subTemplates=SubTemplatesType)?
	'}';

Definitions returns Definitions:
	'Definitions'
	'{'
	'definition' '{' definition+=DefinitionType ("," definition+=DefinitionType)* '}'
	'}';

RulesType returns RulesType:
	'RulesType'
	'{'
	'attributes' '{' attributeRule+=AttributeRule ("," attributeRule+=AttributeRule)* '}'
	'}';

SubTemplatesType returns SubTemplatesType:
	'['
	'conceptTemplate' '{' conceptTemplate+=ConceptTemplate ("," conceptTemplate+=ConceptTemplate)* '}'
	']';

ApplicableEntityType returns ApplicableEntityType:
	'ApplicableEntityType' /* TODO: implement this rule and an appropriate IValueConverter */;

ApplicableSchemaType returns ApplicableSchemaType:
	'IFC4' | 'IFC2X3';

Boolean returns type::Boolean:
	'true' | 'false';

DefinitionType returns DefinitionType:
	{DefinitionType}
	'DefinitionType'
	'{'
	('body' body=BodyType)?
	('link' '{' link+=LinkType ("," link+=LinkType)* '}')?
	'}';

BodyType returns BodyType:
	{BodyType}
	'BodyType'
	'{'
	('value' value=String0)?
	('lang' lang=LANGUAGE)?
	('tags' tags=TagsType)?
	'}';

LinkType returns LinkType:
	'LinkType'
	'{'
	('category' category=CategoryType)?
	'href' href=AnyURI
	('lang' lang=LANGUAGE)?
	('title' title=NORMALIZED_STRING)?
	'}';

String0 returns type::String:
	ID;

LANGUAGE returns type::Language:
	STRING;

TagsType returns TagsType:
	STRING;

enum CategoryType returns CategoryType:
	definition='definition' | agreement='agreement' | diagram='diagram' | instantiation='instantiation' |
	example='example';

AttributeRule returns AttributeRule:
	'AttributeRule' attributeName=String0
	'{'
	('description' description=String0)?
	('ruleID' ruleID=NORMALIZED_STRING)?
	('cardinality' cardinality=CardinalityType)?
	('entities' entityRules=EntityRulesType)?
	('constraints' constraints=ConstraintsType)?
	'}';

EntityRulesType returns EntityRulesType:
	{EntityRulesType}
	'[' entityRule+=EntityRule ("," entityRule+=EntityRule)* ']';

EntityRule returns EntityRule:
	'EntityRule' entityName=String0
	'{'
	('references' references=ReferencesType)?
	'attributes' attributeRules=AttributeRulesType
	('constraints' constraints=ConstraintsType)?
	('description' description=String0)?
	('ruleID' ruleID=NORMALIZED_STRING)?
	('cardinality' cardinality=CardinalityType)?
	'}';

ReferencesType:
	'{'
	template=GenericReference
	idPrefix=NORMALIZED_STRING
	'}';

AttributeRulesType returns AttributeRulesType:
	{AttributeRulesType}
	// group+=
	'[' attributeRule+=AttributeRule ("," attributeRule+=AttributeRule)* ']';

ConstraintsType returns ConstraintsType:
	{ConstraintsType}
	'ConstraintsType';

enum CardinalityType returns CardinalityType:
	asSchema='asSchema' | Zero='Zero' | ZeroToOne='ZeroToOne' | One='One' | OneToMany='OneToMany';

ModelView returns ModelView:
	'ModelView'
	'{'
	'applicableSchema' applicableSchema=SCHEMA_NAME
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	'name' name=NORMALIZED_STRING
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	'uuid' uuid=UUID
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	('baseView' baseView=GenericReference)?
	('exchangeRequirements' exchangeRequirements=ExchangeRequirementsType)?
	('roots' roots=RootsType)?
	'}';

GenericReference returns GenericReference:
	{GenericReference}
	'{'
	('href' href=AnyURI)?
	('ref' ref=UUID)?
	'}';

ExchangeRequirementsType returns ExchangeRequirementsType:
	'{'
	'exchangeRequirement' '{' exchangeRequirement+=ExchangeRequirementType (","
	exchangeRequirement+=ExchangeRequirementType)* '}'
	'}';

RootsType returns RootsType:
	'{'
	'conceptRoot' '{' conceptRoot+=ConceptRoot ("," conceptRoot+=ConceptRoot)* '}'
	'}';

terminal SCHEMA_NAME returns SchemaName:
	'IFC2X2FINAL' | 'IFC2X3' | 'IFC2XFINAL' | 'IFC4';

ExchangeRequirementType returns ExchangeRequirementType:
	'ExchangeRequirementType' name=NORMALIZED_STRING
	'{'
	('applicability' applicability=Applicability)?
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	'uuid' uuid=UUID
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	'}';

enum Applicability returns Applicability:
	export='export' | ^import='import' | both='both';

ConceptRoot returns ConceptRoot:
	'ConceptRoot' name=NORMALIZED_STRING
	'{'
	('applicableRootEntity' applicableRootEntity=NORMALIZED_STRING)?
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	'uuid' uuid=UUID
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	('applicability' applicability=ApplicabilityType)?
	('concepts' concepts=ConceptsType)?
	'}';

ApplicabilityType returns ApplicabilityType:
	'ApplicabilityType'
	'{'
	('definitions' definitions=Definitions)?
	'template' template=GenericReference
	'templateRules' templateRules=TemplateRules
	'}';

ConceptsType returns ConceptsType:
	'{'
	'concept' '{' concept+=Concept ("," concept+=Concept)* '}'
	'}';

TemplateRules returns TemplateRules:
	{TemplateRules}
	'TemplateRules'
	'{'
	('description' description=String0)?
	('operator' operator=OperatorType)?
	'}';

enum OperatorType returns OperatorType:
	and='and' | or='or' | not='not' | nand='nand' | nor='nor' | xor='xor' | nxor='nxor';

Concept returns Concept:
	'Concept' name=NORMALIZED_STRING
	'{'
	('author' author=NORMALIZED_STRING)?
	('baseConcept' baseConcept=UUID)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('override' override=Boolean)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	'uuid' uuid=UUID
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	'templateRef' template=GenericReference
	('requirements' requirements=Requirements)?
	'templateRules' templateRules=TemplateRules
	'}';

Requirements returns Requirements:
	'Requirements'
	'{'
	'requirement' '{' requirement+=Requirement ("," requirement+=Requirement)* '}'
	'}';

Requirement returns Requirement:
	'Requirement'
	'{'
	('value' value=String0)?
	('applicability' applicability=Applicability)?
	'exchangeRequirement' exchangeRequirement=UUID
	'requirement' requirement=RequirementType
	'}';

enum RequirementType returns RequirementType:
	mandatory='mandatory' | recommended='recommended' | notRelevant='notRelevant' | notRecommended='notRecommended' |
	excluded='excluded' | optional='optional';

terminal UUID returns type::NormalizedString:
	HEX_OCTED_4 "-" HEX_OCTED_2 "-" HEX_OCTED_2 "-" HEX_OCTED HEX_OCTED "-" HEX_OCTED_6;

terminal HEX_OCTED_6:
	HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED;

terminal HEX_OCTED_2:
	HEX_OCTED HEX_OCTED;

terminal HEX_OCTED_4:
	HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED;

terminal HEX_OCTED:
	HEX_DIGIT HEX_DIGIT;

terminal HEX_DIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');