// automatically generated by Xtext
grammar org.buildingsmart.mvd.tmvd.TextualMVD with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2003/XMLType" as type
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://buildingsmart-tech.org/mvdXML/mvdXML1-1"

MvdXML returns MvdXML:
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	('version' version=NORMALIZED_STRING)?
	'mvd' name=MVD_NAME 'uuid' uuid=UUID
	';'
	('templates' templates=TemplatesType)?
	('views' views=ViewsType)?;

TemplatesType returns TemplatesType:
	'[' conceptTemplate+=ConceptTemplate ("," conceptTemplate+=ConceptTemplate)* ']';

ViewsType returns ViewsType:
	'[' modelView+=ModelView ("," modelView+=ModelView)* ']';

AnyURI returns type::AnyURI:
	'AnyURI' STRING /* TODO: implement this rule and an appropriate IValueConverter */;

ConceptTemplate returns ConceptTemplate:
	'@UUID(' uuid=UUID ')'
	'ConceptTemplate' name=ID
	'{'
	('applicableEntity' applicableEntity=ApplicableEntityType)?
	'applicableSchema' applicableSchema=ApplicableSchemaType
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('isPartial' isPartial=Boolean)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	('rules' rules=RulesType)?
	('subTemplates' subTemplates=SubTemplatesType)?
	'}';

Definitions returns Definitions:
	'Definitions'
	'{'
	'definition' '{' definition+=DefinitionType ("," definition+=DefinitionType)* '}'
	'}';

RulesType returns RulesType:
	'{'
	'attributes' '[' attributeRule+=AttributeRule ("," attributeRule+=AttributeRule)* ']'
	'}';

SubTemplatesType returns SubTemplatesType:
	'['
	'conceptTemplate' '{' conceptTemplate+=ConceptTemplate ("," conceptTemplate+=ConceptTemplate)* '}'
	']';

ApplicableEntityType returns ApplicableEntityType:
	ID;

ApplicableSchemaType returns ApplicableSchemaType:
	'IFC4' | 'IFC2X3';

Boolean returns type::Boolean:
	'true' | 'false';

DefinitionType returns DefinitionType:
	{DefinitionType}
	'DefinitionType'
	'{'
	('body' body=BodyType)?
	('link' '{' link+=LinkType ("," link+=LinkType)* '}')?
	'}';

BodyType returns BodyType:
	{BodyType}
	'BodyType'
	'{'
	('value' value=STRING0)?
	('lang' lang=LANGUAGE)?
	('tags' tags=TAGS_TYPE)?
	'}';

LinkType returns LinkType:
	'LinkType'
	'{'
	('category' category=CategoryType)?
	'href' href=AnyURI
	('lang' lang=LANGUAGE)?
	('title' title=NORMALIZED_STRING)?
	'}';

AttributeRule returns AttributeRule:
	'AttributeRule' attributeName=ID
	'{'
	('description' description=STRING0)?
	('ruleID' ruleID=ID)?
	('cardinality' cardinality=CardinalityType)?
	('entities' entityRules=EntityRulesType)?
	('constraints' constraints=ConstraintsType)?
	'}';

EntityRulesType returns EntityRulesType:
	{EntityRulesType}
	'[' entityRule+=EntityRule ("," entityRule+=EntityRule)* ']';

EntityRule returns EntityRule:
	'EntityRule' entityName=ID
	'{'
	('reference' references=ReferencesType)?
	('attributes' attributeRules=AttributeRulesType)?
	('constraints' constraints=ConstraintsType)?
	('description' description=STRING0)?
	('ruleID' ruleID=NORMALIZED_STRING)?
	('cardinality' cardinality=CardinalityType)?
	'}';

ReferencesType:
	'{'
	'template' template=GenericReference
	('prefix' idPrefix=NORMALIZED_STRING)?
	'}';

AttributeRulesType returns AttributeRulesType:
	{AttributeRulesType}
	// group+=
	'[' attributeRule+=AttributeRule ("," attributeRule+=AttributeRule)* ']';

ConstraintsType returns ConstraintsType:
	{ConstraintsType}
	'ConstraintsType';

ModelView returns ModelView:
	'ModelView' name=ID 'uuid' uuid=UUID
	'{'
	'applicableSchema' applicableSchema=SCHEMA_NAME
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	('baseView' baseView=GenericReference)?
	('exchangeRequirements' exchangeRequirements=ExchangeRequirementsType)?
	('roots' roots=RootsType)?
	'}';

GenericReference returns GenericReference:
	{GenericReference}
	'{'
	('href' href=AnyURI)?
	('ref' ref=UUID)?
	'}';

ExchangeRequirementsType returns ExchangeRequirementsType:
	'[' exchangeRequirement+=ExchangeRequirementType ("," exchangeRequirement+=ExchangeRequirementType)* ']';

RootsType returns RootsType:
	'{'
	'conceptRoot' '{' conceptRoot+=ConceptRoot ("," conceptRoot+=ConceptRoot)* '}'
	'}';

ExchangeRequirementType returns ExchangeRequirementType:
	'ExchangeRequirementType' name=NORMALIZED_STRING 'uuid' uuid=UUID
	'{'
	('applicability' applicability=Applicability)?
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	'}';

ConceptRoot returns ConceptRoot:
	'ConceptRoot' name=NORMALIZED_STRING
	'{'
	('applicableRootEntity' applicableRootEntity=ID)?
	('author' author=NORMALIZED_STRING)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	'uuid' uuid=UUID
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	('applicability' applicability=ApplicabilityType)?
	('concepts' concepts=ConceptsType)?
	'}';

ApplicabilityType returns ApplicabilityType:
	'ApplicabilityType'
	'{'
	('definitions' definitions=Definitions)?
	'template' template=GenericReference
	'templateRules' templateRules=TemplateRules
	'}';

ConceptsType returns ConceptsType:
	'[' concept+=Concept ("," concept+=Concept)* ']';

TemplateRules returns TemplateRules:
	{TemplateRules}
	'TemplateRules'
	'{'
	('description' description=STRING0)?
	('operator' operator=OperatorType)? // recursive definition of TemplateRules
	('templateRules' '[' templateRules+=TemplateRules (',' templateRules+=TemplateRules)* ']')?
	('templateRule' '[' templateRule+=TemplateRuleType (',' templateRule+=TemplateRuleType)* ']')?
	'}';

TemplateRuleType returns TemplateRuleType:
	'TemplateRule' '{'
	('description' description=STRING)?
	'parameters' parameters=STRING
	'}';

Concept returns Concept:
	'Concept' name=NORMALIZED_STRING
	'{'
	('author' author=NORMALIZED_STRING)?
	('baseConcept' baseConcept=UUID)?
	('code' code=NORMALIZED_STRING)?
	('copyright' copyright=AnyURI)?
	('override' override=Boolean)?
	('owner' owner=NORMALIZED_STRING)?
	('status' status=StatusType)?
	'uuid' uuid=UUID
	('version' version=NORMALIZED_STRING)?
	('definitions' definitions=Definitions)?
	'template' template=GenericReference
	('requirements' requirements=Requirements)?
	'templateRules' templateRules=TemplateRules
	'}';

Requirements returns Requirements:
	'[' requirement+=Requirement ("," requirement+=Requirement)* ']';

Requirement returns Requirement:
	requirement=RequirementType 'Requirement'
	'{'
	('value' value=STRING0)?
	('applicability' applicability=Applicability)?
	'exchangeRequirement' exchangeRequirement=UUID
	'}';

enum CardinalityType returns CardinalityType:
	asSchema='asSchema' | Zero='Zero' | ZeroToOne='ZeroToOne' | One='One' | OneToMany='OneToMany';

enum Applicability returns Applicability:
	export='export' | ^import='import' | both='both';

enum RequirementType returns RequirementType:
	mandatory='mandatory' | recommended='recommended' | notRelevant='notRelevant' | notRecommended='notRecommended' |
	excluded='excluded' | optional='optional';

enum OperatorType returns OperatorType:
	and='and' | or='or' | not='not' | nand='nand' | nor='nor' | xor='xor' | nxor='nxor';

enum CategoryType returns CategoryType:
	definition='definition' | agreement='agreement' | diagram='diagram' | instantiation='instantiation' |
	example='example';

enum StatusType returns StatusType:
	sample='sample' | proposal='proposal' | draft='draft' | candidate='candidate' | final='final' |
	deprecated='deprecated' | noStatus='noStatus';

NORMALIZED_STRING returns type::NormalizedString:
	STRING;

MVD_NAME returns type::NormalizedString:
	ID;

STRING0 returns type::String:
	ID;

LANGUAGE returns type::Language:
	STRING;

TAGS_TYPE returns TagsType:
	STRING;

SCHEMA_NAME returns SchemaName:
	'IFC4' | 'IFC2X3';

terminal UUID returns type::NormalizedString:
	HEX_OCTED_4 "-" HEX_OCTED_2 "-" HEX_OCTED_2 "-" HEX_OCTED HEX_OCTED "-" HEX_OCTED_6;

terminal HEX_OCTED_6:
	HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED;

terminal HEX_OCTED_2:
	HEX_OCTED HEX_OCTED;

terminal HEX_OCTED_4:
	HEX_OCTED HEX_OCTED HEX_OCTED HEX_OCTED;

terminal HEX_OCTED:
	HEX_DIGIT HEX_DIGIT;

terminal HEX_DIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');