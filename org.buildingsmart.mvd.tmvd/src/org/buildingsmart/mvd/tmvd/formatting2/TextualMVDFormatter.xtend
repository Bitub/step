/*
 * generated by Xtext
 */
package org.buildingsmart.mvd.tmvd.formatting2;

import com.google.inject.Inject
import org.buildingsmart.mvd.mvdxml.ApplicabilityType
import org.buildingsmart.mvd.mvdxml.AttributeRule
import org.buildingsmart.mvd.mvdxml.AttributeRulesType
import org.buildingsmart.mvd.mvdxml.Concept
import org.buildingsmart.mvd.mvdxml.ConceptRoot
import org.buildingsmart.mvd.mvdxml.ConceptTemplate
import org.buildingsmart.mvd.mvdxml.ConceptsType
import org.buildingsmart.mvd.mvdxml.ConstraintType
import org.buildingsmart.mvd.mvdxml.ConstraintsType
import org.buildingsmart.mvd.mvdxml.DefinitionType
import org.buildingsmart.mvd.mvdxml.Definitions
import org.buildingsmart.mvd.mvdxml.EntityRule
import org.buildingsmart.mvd.mvdxml.EntityRulesType
import org.buildingsmart.mvd.mvdxml.ExchangeRequirementType
import org.buildingsmart.mvd.mvdxml.ExchangeRequirementsType
import org.buildingsmart.mvd.mvdxml.LinkType
import org.buildingsmart.mvd.mvdxml.ModelView
import org.buildingsmart.mvd.mvdxml.MvdXML
import org.buildingsmart.mvd.mvdxml.MvdXmlPackage
import org.buildingsmart.mvd.mvdxml.ReferencesType
import org.buildingsmart.mvd.mvdxml.Requirement
import org.buildingsmart.mvd.mvdxml.Requirements
import org.buildingsmart.mvd.mvdxml.RootsType
import org.buildingsmart.mvd.mvdxml.RulesType
import org.buildingsmart.mvd.mvdxml.SubTemplatesType
import org.buildingsmart.mvd.mvdxml.TemplateRules
import org.buildingsmart.mvd.mvdxml.TemplatesType
import org.buildingsmart.mvd.mvdxml.ViewsType
import org.buildingsmart.mvd.tmvd.services.TextualMVDGrammarAccess
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.emf.ecore.EAttribute
import org.buildingsmart.mvd.mvdxml.TemplateRuleType

class TextualMVDFormatter extends AbstractFormatter2 {

	@Inject extension TextualMVDGrammarAccess

	def indentCurlyBrackets(EObject eObject, extension IFormattableDocument doc) {
		return eObject.indent( {
			'{' -> '}'
		}, doc)
	}

	def indentBrackets(EObject eObject, extension IFormattableDocument doc) {
		return eObject.indent( {
			'[' -> ']'
		}, doc)
	}

	def indent(EObject eObject, Pair<String, String> pair, extension IFormattableDocument doc) {

		var secondSemanticRegion = eObject.regionFor.keyword(pair.value)

		interior(
			eObject.regionFor.keyword(pair.key).prepend[oneSpace].append[newLine], // setNewLines(0, 1, 1)],
			secondSemanticRegion,
			[indent]
		)

		return secondSemanticRegion
	}

	def dispatch void format(MvdXML mvd, extension IFormattableDocument doc) {

		mvd.formatUUID(MvdXmlPackage.Literals.MVD_XML__UUID, doc)
		mvd.regionFor.element(mvdXMLAccess.RPARENTerminalRuleCall_4).append[setNewLines(0, 1, 1)]
		mvd.regionFor.feature(MvdXmlPackage.Literals.MVD_XML__NAME).surround[oneSpace].append[newLines = 2]

		val sections = #["templates", "views"]

		// align all values
		mvd.eClass.EStructuralFeatures.filter [
			return !sections.contains(name)
		].forEach [
			mvd.regionFor.keyword(name).prepend[noIndentation].append[space = "\t\t"]
		]

		// surround with newlines
		mvd.regionFor.keywords(sections).forEach [
			prepend[newLines = 2]
			append[oneSpace]
		]

		format(mvd.templates, doc);
		format(mvd.views, doc);
	}

	def dispatch void format(TemplatesType templates, extension IFormattableDocument document) {
		templates.indentCurlyBrackets(document)

		for (ConceptTemplate conceptTemplate : templates.conceptTemplate) {
			format(conceptTemplate, document);
		}
	}

	def dispatch void format(ViewsType views, extension IFormattableDocument document) {
		views.indentCurlyBrackets(document).append[newLine]

		for (ModelView modelView : views.modelView) {
			format(modelView, document);
		}
	}

	def formatListSeperator(EObject object, extension IFormattableDocument document) {
		object.regionFor.keyword(",").prepend[noSpace].append[newLine]
	}

	def void formatUUID(EObject object, EStructuralFeature feature, extension IFormattableDocument document) {

		object.regionFor.keywords("@", "UUID", "(", ")").forEach [
			surround[noSpace]
		]
		object.regionFor.feature(feature).surround[noSpace]
		object.regionFor.keyword(")").append[newLine]
	}

	def void formatRuleId(EObject object, EStructuralFeature feature, extension IFormattableDocument document) {

		object.regionFor.keywords("@", "RuleID", "(", ")").forEach [
			surround[noSpace]
		]
		object.regionFor.feature(feature).surround[noSpace]
		object.regionFor.keyword(")").append[newLine]
	}

	def dispatch void format(ConceptTemplate concepttemplate, extension IFormattableDocument document) {
		concepttemplate.formatUUID(MvdXmlPackage.Literals.CONCEPT_TEMPLATE__UUID, document)
		concepttemplate.regionFor.element(conceptTemplateAccess.RPARENTerminalRuleCall_4).append[setNewLines(0, 1, 1)]

		concepttemplate.indentCurlyBrackets(document).append[newLine]

		concepttemplate.regionFor.feature(MvdXmlPackage.Literals.CONCEPT_TEMPLATE__APPLICABLE_ENTITY).append[newLine]
		concepttemplate.regionFor.feature(MvdXmlPackage.Literals.CONCEPT_TEMPLATE__APPLICABLE_SCHEMA).append[newLine]
		concepttemplate.regionFor.feature(MvdXmlPackage.Literals.CONCEPT_TEMPLATE__AUTHOR).append[newLine]

//		format(concepttemplate.getDefinitions(), document);
		format(concepttemplate.rules, document);
		format(concepttemplate.getSubTemplates(), document);
	}

	def dispatch void format(Definitions definitions, extension IFormattableDocument document) {

		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (DefinitionType definition : definitions.getDefinition()) {
			format(definition, document);
		}
	}

	def dispatch void format(RulesType rules, extension IFormattableDocument document) {

		rules.indentBrackets(document).append[newLine]

		for (AttributeRule attributeRule : rules.attributeRule) {
			format(attributeRule, document);
		}
	}

	def dispatch void format(SubTemplatesType subtemplatestype, extension IFormattableDocument document) {
		subtemplatestype.indentBrackets(document).append[newLine]
		subtemplatestype.formatListSeperator(document)
		for (ConceptTemplate conceptTemplate : subtemplatestype.getConceptTemplate()) {
			format(conceptTemplate, document);
		}
	}

	def dispatch void format(DefinitionType definitiontype, extension IFormattableDocument document) {

		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		format(definitiontype.getBody(), document);
		for (LinkType link : definitiontype.getLink()) {
			format(link, document);
		}
	}

	def dispatch void format(AttributeRule attributerule, extension IFormattableDocument document) {
		attributerule.formatRuleId(MvdXmlPackage.Literals.ATTRIBUTE_RULE__RULE_ID, document)
		attributerule.indentCurlyBrackets(document).append[newLine]

		if (!attributerule.isMultiline) {
			attributerule.regionFor.feature(MvdXmlPackage.Literals.ATTRIBUTE_RULE__NAME).prepend[oneSpace].append [
				newLine
			]
		} else {
			attributerule.regionFor.feature(MvdXmlPackage.Literals.ATTRIBUTE_RULE__NAME).surround[oneSpace]
		}

		attributerule.entityRules.format(document)
		format(attributerule.constraints, document);
	}

	def dispatch void format(EntityRulesType entityrulestype, extension IFormattableDocument document) {
		entityrulestype.formatListSeperator(document)

		for (EntityRule entityRule : entityrulestype.entityRule) {
			format(entityRule, document);
		}
	}

	def dispatch void format(EntityRule entityrule, extension IFormattableDocument document) {

		entityrule.indentCurlyBrackets(document).append[newLine]
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
//		format(entityrule.getReferences(), document);
		format(entityrule.attributeRules, document);
//		format(entityrule.getConstraints(), document);
	}

	def dispatch void format(ReferencesType referencestype, extension IFormattableDocument document) {

		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		format(referencestype.getTemplate(), document);
	}

	def dispatch void format(AttributeRulesType attributerulestype, extension IFormattableDocument document) {
		attributerulestype.formatListSeperator(document)
		for (AttributeRule attributeRule : attributerulestype.getAttributeRule()) {
			format(attributeRule, document);
		}
	}

	def dispatch void format(ConstraintsType constraintstype, extension IFormattableDocument document) {
		constraintstype.indentBrackets(document)
		constraintstype.constraint.forEach [
			format.append[newLine]
		]
	}

	def dispatch void format(ConstraintType constraintType, extension IFormattableDocument document) {
		constraintType.regionFor.keyword("=>").append[oneSpace]
	}

	def dispatch void format(ModelView modelview, extension IFormattableDocument document) {
		modelview.formatUUID(MvdXmlPackage::Literals.MODEL_VIEW__UUID, document)
		modelview.indentCurlyBrackets(document).append[newLine]

		format(modelview.getDefinitions(), document);
		format(modelview.getBaseView(), document);
		format(modelview.exchangeRequirements, document);
		format(modelview.roots, document);
	}

	def dispatch void format(ExchangeRequirementsType exchangerequirementstype,
		extension IFormattableDocument document) {
		exchangerequirementstype.indentBrackets(document).append [
			newLine
		]
		exchangerequirementstype.formatListSeperator(document)

		for (ExchangeRequirementType exchangeRequirement : exchangerequirementstype.exchangeRequirement) {
			format(exchangeRequirement, document);
		}
	}

	def dispatch void format(RootsType rootstype, extension IFormattableDocument document) {
		rootstype.indentBrackets(document).append[newLine]
		rootstype.formatListSeperator(document)

		for (ConceptRoot conceptRoot : rootstype.conceptRoot) {
			format(conceptRoot, document);
		}
	}

	def dispatch void format(ExchangeRequirementType exchangerequirementtype, extension IFormattableDocument document) {
		exchangerequirementtype.formatUUID(MvdXmlPackage::Literals.EXCHANGE_REQUIREMENT_TYPE__UUID, document)
		exchangerequirementtype.indentBrackets(document)

		format(exchangerequirementtype.definitions, document);
	}

	def dispatch void format(ConceptRoot conceptroot, extension IFormattableDocument document) {
		conceptroot.formatUUID(MvdXmlPackage::Literals.CONCEPT_ROOT__UUID, document)
		conceptroot.indentBrackets(document).append[newLine]

		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		format(conceptroot.getDefinitions(), document);
		format(conceptroot.getApplicability(), document);
		format(conceptroot.concepts, document);
	}

	def dispatch void format(ApplicabilityType applicabilitytype, extension IFormattableDocument document) {

		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		format(applicabilitytype.getDefinitions(), document);
		format(applicabilitytype.getTemplate(), document);
		format(applicabilitytype.getTemplateRules(), document);
	}

	def dispatch void format(ConceptsType conceptstype, extension IFormattableDocument document) {
		conceptstype.indentBrackets(document).append[newLine]
		conceptstype.formatListSeperator(document)

		for (Concept concept : conceptstype.concept) {
			format(concept, document);
		}
	}

	def dispatch void format(TemplateRules templaterules, extension IFormattableDocument document) {

		var firstSemanticRegion = templaterules.regionFor.keyword("{")
		var secondSemanticRegion = templaterules.regionFor.keyword("}")

		interior(
			firstSemanticRegion.prepend[oneSpace].append[setNewLines(0, 1, 1)],
			secondSemanticRegion,
			[indent]
		)

		templaterules.regionFor.feature(MvdXmlPackage.Literals.TEMPLATE_RULES__OPERATOR).append[oneSpace]

		templaterules.templateRules.forEach [
			format(document)
		]

		templaterules.templateRule.forEach [
			format(document)
		]
	}

	def dispatch void format(TemplateRuleType templateRuleType, extension IFormattableDocument document) {
		templateRuleType.indentCurlyBrackets(document).append[newLine]
	}

	def dispatch void format(Concept concept, extension IFormattableDocument document) {
		concept.formatUUID(MvdXmlPackage::Literals.CONCEPT__UUID, document)
		concept.indentBrackets(document).append[newLine]

		format(concept.getDefinitions(), document);
		format(concept.getTemplate(), document);
		format(concept.getRequirements(), document);
		format(concept.templateRules, document);
	}

	def dispatch void format(Requirements requirements, extension IFormattableDocument document) {

		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Requirement requirement : requirements.getRequirement()) {
			format(requirement, document);
		}
	}
}
